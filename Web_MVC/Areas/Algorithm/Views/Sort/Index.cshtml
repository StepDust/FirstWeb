
@{
    ViewBag.Title = "Index";
    Layout = "~/Views/Shared/_Layout.cshtml";
    string[,] str =
    {
        {"桶排序","one" },
        {"冒泡排序","two" }
    };
}
@* 侧边栏 *@
@Html.Partial("_Sidebar", str)

<!-- 桶排序 -->
<fieldset id="@str[0,1]">
    <legend>@str[0, 0]</legend>
    <blockquote class="layui-elem-quote ">
        <p>优点：非常快，简单</p>
        <p>缺点：消耗空间，无法处理小数，仅仅只能排序</p>
        <p>题目：一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，要求对这500 万元素的数组进行排序。</p>
    </blockquote>
    <blockquote class="layui-elem-quote layui-quote-nm layui-row">
        <b class="layui-col-sm1">思路：</b>
        <p class="layui-col-sm11">建立长度为801的数组，按每人减去100分，转为0~800的索引，每出现一个数字，对应索引加一，顺序输出数组</p>
    </blockquote>

    <blockquote class="layui-elem-quote layui-quote-nm">
        <div class="layui-row layui-input-item-r">
            <div class="layui-col-sm11"><input placeholder="输入数字，逗号分割，[Min:100,Max:900]" class="layui-input"></div>
            <div class="layui-col-sm1"><button class="layui-btn layui-btn-block" onclick="Algo(this,'/Sort/BucketSort')">排序</button></div>
        </div>
    </blockquote>
    <pre class="layui-code code" lay-title="C#">
        /// <summary>
        /// 桶排序
        /// </summary>
        /// <param name="arr">带排序数组< /param>
        /// <param name="min">最小值< /param>
        /// <param name="max">最大值< /param>
        /// <returns></returns>
        public int[] BucketSort(double[] arr, int min, int max) {
            // 准备桶
            int[] num = new int[max - min + 1];
            // 差值为：  (最小值)100-(初始索引)0=100
            int diff = min - 0;
            List< int> list = new List< int>();

            // 开始排序
            for (int i = 0; i < arr.Length; i++) {
                // 满足条件，[100,900]
                if (min <= arr[i] && arr[i] <= max) {
                    // 对应索引加一，索引对应的值，表示当前数字出现的次数
                    num[(int)arr[i] - diff]++;
                }
            }
            // 输出
            for (int i = 0; i < num.Length; i++) {
                // 当 num[i] 为0时，表示 i 没有出现过
                if (num[i] <= 0) continue;
                // 输出 num[i] 个 i 
                for (int j = 0; j < num[i]; j++)
                    list.Add(i);
            }
            return list.ToArray();
        }
      </pre>
</fieldset>
<!-- 冒泡排序 -->
<fieldset id="@str[1,1]">
    <legend>@str[1, 0]</legend>
    <blockquote class="layui-elem-quote ">
        <p>优点：适用广泛，稳定</p>
        <p>缺点：较慢，时间复杂度高</p>
        <p>题目：一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，要求对这500 万元素的数组进行排序。</p>
    </blockquote>
    <blockquote class="layui-elem-quote layui-quote-nm layui-row">
        <b class="layui-col-sm1">思路：</b>
        <p class="layui-col-sm11">
        取第一个依次与第二、三、四...个比较（第一个循环），每次比较时，判断哪个数更小，较小数放置第一位，全部比较完毕后为“一趟”<br />
        然后取第二个，继续依次与第三、四...个比较（第二个循环）</p>
    </blockquote>

    <blockquote class="layui-elem-quote layui-quote-nm">
        <div class="layui-row layui-input-item-r">
            <div class="layui-col-sm11"><input placeholder="输入数字，逗号分割" class="layui-input"></div>
            <div class="layui-col-sm1"><button class="layui-btn layui-btn-block" onclick="Algo(this,'/Sort/BubbleSort')">排序</button></div>
        </div>
    </blockquote>
    <!--代码块-->
    <pre class="layui-code code" lay-title="C#">
        /// <summary>
        /// 冒泡排序
        /// </summary>
        /// <param name="arr">待排序数组< /param>
        /// <returns></returns>
        public static double[] BubbleSort(double[] arr) {

            // 依次获取未排序的数字，最后一个不获取
            for (int i = 0; i < arr.Length - 1; i++) {
                // 循环获取未排序数字之后的数字
                for (int j = i + 1; j < arr.Length; j++) {
                    if (arr[i] > arr[j]) {
                        // 交换两个数字
                        arr[i] += arr[j];
                        arr[j] = arr[i] - arr[j];
                        arr[i] = arr[i] - arr[j];
                    }
                }
            }
            return arr;
        }
      </pre>
</fieldset>